api -> server -> service -> biz -> data

![kratos ddd](https://go-kratos.dev/images/ddd.png)

## 项目数据流概览

整体是 Kratos 分层 + Wire 依赖注入：请求从 HTTP/gRPC 进来，经过 Service → Biz(Logic) → Data(Repo) → DAO → 数据库，再原路返回。

### 1. 分层与依赖关系

┌─────────────────────────────────────────────────────────────────────────┐

│ Transport 层                              │

│ HTTP (server/http.go) / gRPC (server/grpc.go)              │

│ → 注册 ReportService，请求进入 service 层                │

└─────────────────────────────────────────────────────────────────────────┘

​                  ↓

┌─────────────────────────────────────────────────────────────────────────┐

│ Service 层 (internal/service/)                      │

│ ReportService 内嵌 *biz.Biz                       │

│ → 把 API 的 Request 转成 vo，调用 biz 层；把 biz 返回的 vo 转成 Response  │

└─────────────────────────────────────────────────────────────────────────┘

​                  ↓

┌─────────────────────────────────────────────────────────────────────────┐

│ Biz 层 (internal/biz/)                         │

│ Biz 内嵌 *logic.Logic；Logic 里有 Students *logic.Students        │

│ → 业务逻辑：校验、filter 解析、调用 repo                 │

└─────────────────────────────────────────────────────────────────────────┘

​                  ↓

┌─────────────────────────────────────────────────────────────────────────┐

│ Data 层 (internal/data/)                         │

│ Data 内嵌 *StudentsRepo；StudentsRepo 内嵌 *common            │

│ common 持有 dao.Query (GORM Gen)                    │

│ → 封装“怎么查库”：条件、分页、排序，model ↔ vo 转换            │

└─────────────────────────────────────────────────────────────────────────┘

​                  ↓

┌─────────────────────────────────────────────────────────────────────────┐

│ DAO 层 (internal/data/dao/)                       │

│ GORM Gen 生成的 students DAO，对表 students 的 CRUD           │

│ → 实际执行 SQL（Where/First/FindByPage 等）               │

└─────────────────────────────────────────────────────────────────────────┘

​                  ↓

┌─────────────────────────────────────────────────────────────────────────┐

│ 数据库 (MySQL 等)                            │

│ 由 di.NewGormDBV2 根据 conf.Data.Database 创建 *gorm.DB         │

└─────────────────────────────────────────────────────────────────────────┘

也就是说：数据走向是「HTTP/gRPC → Service → Biz(Logic) → Data(Repo) → DAO → DB」。

### 2. 以 Students 为例的调用链

| 步骤 | 位置                        | 作用                                                         |
| :--- | :-------------------------- | :----------------------------------------------------------- |
| 1    | service/students.svc.go     | 收到 v1.CreateStudentsRequest 等，用 gconv.Struct 转成 vo.StudentsVo，调 s.Students.CreateStudents(ctx, &in)（s.Students 即 s.Biz.Logic.Students） |
| 2    | biz/logic/students.go       | 业务层：例如 List 时用 hexpr.Parse 解析 filter、core.FuzzyQuery 做模糊查询处理，然后调 biz.repo.CreateStudents / ListStudentsByExpr 等（repo 实际是 *data.Data） |
| 3    | data/data_z_students_gen.go | Repo：如 GetStudentsDetailById 用 d.dao.Students（GORM Gen 的 DO）做 Where(condition).First()，结果用 gconv.Struct 转成 vo.StudentsVo 返回 |
| 4    | data/dao/students.dao.go    | DAO：d.dao 来自 common.dao，即 dao.Use(db) 的 Query，对 model.Students 表做真正的 GORM 操作 |
| 5    | di/gorm.go                  | 提供 *gorm.DB，被 data.NewDataCommon 使用，最终进 dao.Use(db) 和 Repo |

所以 “数据怎么走的”：

请求体 → Service 转 vo → Biz 调 repo → Data(Repo) 用 dao 查库、model↔vo 转换 → DAO(GORM Gen) 写/读 DB。

### 3. Wire 注入关系（和数据流一致）

cmd/report/wire.go 里 wire.Build 的顺序决定了“谁依赖谁”：

- di.ProviderSet：提供 *gorm.DB、Redis、Nacos 等基础设施。

- data.ProviderSet：NewDataCommon(db) → NewStudentsRepo(common) → NewData(db, external, StudentsRepo)，即 DB → common → StudentsRepo → Data。

- logic.ProviderSet：NewStudents(bootstrap, logger, data) → NewLogic(..., students)，即 Data 注入到 Logic.Students。

- biz.ProviderSet：NewBiz(logic, agg)，Logic 里有 Students。

- service.ProviderSet：New(..., biz)，ReportService 内嵌 *biz.Biz，所以能访问 s.Students。

- server：用 *service.ReportService 注册 HTTP/gRPC 路由。

因此 数据流和 Wire 的依赖方向是一致的：

DB ← DAO ← Data(Repo) ← Biz(Logic) ← Service ← HTTP/gRPC。

### 4. 数据形态在各层的转换

- API 层：v1.*Request / v1.*Response、v1.StudentsData（来自 proto 生成的 Go 类型）。

- Service → Biz：Request 转成 vo（如 vo.StudentsVo、vo.UpdateStudentsForm）。

- Biz ↔ Data：一直用 vo 和 expr（如 hexpr.Expr 表示 filter）。

- Data ↔ DAO：Repo 内部用 model（如 model.Students）和 GORM Gen 的 DO；读出后 gconv.Struct 转成 vo 再返回给 Biz。

总结一句：这个项目的数据是“沿 Kratos 分层从上往下走到 DB，再沿原路返回；类型在 Service 做 proto↔vo，在 Data 做 model↔vo；DB 连接和 Repo/DAO 的组装都由 Wire 在启动时注入完成”。

Biz 到 Data 的衔接就两步：构造注入 + 接口调用。

------

## 1. 构造注入：Data 被注入到 Biz

在 internal/biz/logic/students.go 里：

students.goLines 35-45

func NewStudents(*bootstrap* *conf.Bootstrap, *logger* log.Logger, *data* *data.Data) *Students {

  return &Students{

​    repo: data,

​    *// ...*

  }

}

- NewStudents 的第三个参数是 *data.Data。

- 创建 Students 时把 data 赋给 repo（类型是上面的 students 接口）。

也就是说：Biz 里的 logic.Students 并不自己 new Data，而是由 Wire 在组装应用时先造好 *data.Data，再通过 NewStudents(..., data) 把 Data 传进来，所以 Biz “拿到” Data 是通过构造函数参数注入的。

------

## 2. 接口：Biz 只依赖接口，Data 实现接口

Biz 里依赖的是接口，不是具体类型：

students.goLines 16-27

type students interface {

  hdb.TxImpl

  CreateStudents(*ctx* context.Context, *in* *vo.StudentsVo) error

  UpdateStudentsWithColumn(...) (int64, error)

  DeleteStudentsById(*ctx* context.Context, *id* int64) (int64, error)

  GetStudentsDetailById(*ctx* context.Context, *id* int64) (*vo.StudentsVo, error)

  ListStudentsByExpr(*ctx* context.Context, *expr* *hexpr.Expr, *limit*, *page* int) ([]*vo.StudentsVo, int64, error)

}

type Students struct {

  repo students  *// 这里只依赖接口*

  *// ...*

}

而 *data.Data 实现了这个接口，因为 Data 内嵌了 *StudentsRepo，这些方法都在 StudentsRepo 上：

data_z_gen.goLines 24-29

*// Data .*

type Data struct {

  hdb.TxImpl

  *external.External

  *StudentsRepo  *// 内嵌，Data 拥有 CreateStudents、GetStudentsDetailById* *等方法*

}

所以：Biz 到 Data 的“类型关系”是：Biz 依赖 students 接口，Data（通过内嵌 *StudentsRepo）实现了 students，Wire 在构造时把 *data.Data 当作 students 传进 Biz。

------

## 3. 调用时：Biz → Data 的调用链

业务方法里只是调接口：

students.goLines 46-48

func (*biz* *Students) CreateStudents(*ctx* context.Context, *in* *vo.StudentsVo) error {

  return biz.repo.CreateStudents(ctx, in)

}

- biz.repo 实际就是上面注入的 *data.Data。

- biz.repo.CreateStudents(...) = (*data.Data).CreateStudents(...)，最终会调到 Data 内嵌的 *StudentsRepo 的实现。

所以：Biz 到 Data 的“怎么到”就是：通过 biz.repo.xxx() 调用，而 repo 在运行时就是 *data.Data。

------

## 4. Wire 里谁造 Data、谁造 Students（保证 Biz 能拿到 Data）

在 internal/data/data_z_gen.go：

data_z_gen.goLines 17-22

var ProviderSet = wire.NewSet(

  external.NewExternal,

  NewData,

  NewDataCommon,

  NewStudentsRepo,

)

Wire 会先构造 NewDataCommon、NewStudentsRepo，再 NewData(db, external, StudentsRepo) 得到 *data.Data。

在 internal/biz/logic/logic.go：

logic.goLines 23-26

func NewLogic(

  *example* *Example,

  *students* *Students,

) *Logic {

而 *Students 来自 NewStudents(bootstrap, logger, data)（在 logic.ProviderSet 里，见同目录下 wire 的 ProviderSet）。Wire 发现 NewStudents 需要 *data.Data，就会用前面已经造好的 *data.Data 来调 NewStudents。

所以：Biz 到 Data 在 Wire 里的体现是：先 data.ProviderSet 造出 *data.Data，再 logic 的 NewStudents(data) 把 Data 注入进 Students，从而 Biz（Logic.Students）就持有了 Data。

------

一句话：Biz 到 Data 是通过 Wire 在 NewStudents(bootstrap, logger, data) 里把 *data.Data 注入成 Students.repo，Biz 只依赖 students 接口，运行时 biz.repo 就是 Data，所以所有 biz.repo.xxx() 都会走到 Data（再转到 StudentsRepo）去访问数据库。